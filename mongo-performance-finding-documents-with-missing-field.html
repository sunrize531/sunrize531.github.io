<!DOCTYPE html>
<html lang="english">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
        <title>BUGGER.ONLINE</title>
        <meta charset="utf-8" />

<!-- <link rel="stylesheet" type="text/css" href="/theme/css/normalize.css" /> -->
<link rel="stylesheet" type="text/css" href="/theme/css/style.css" />



</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">BUGGER.ONLINE <strong></strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/mongo-performance-finding-documents-with-missing-field.html" rel="bookmark"
         title="Permalink to Mongo performance - finding documents with missing field.">Mongo performance - finding documents with missing field.</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2018-03-31T12:00:00+00:00">
      Sat 31 March 2018
    </time>
    <address class="vcard author">
      By           <a class="url fn" href="/author/ivan-filimonov.html">Ivan Filimonov</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>We need to find the documents that have value in certain field less then given.
It would be no problem if the field existed in all the documents and it's indexed, of course. 
I.e. our collection looks like:</p>
<div class="highlight"><pre><span></span>{&quot;_id&quot; : &quot;00001&quot;, &quot;value&quot;: 1}
{&quot;_id&quot; : &quot;00002&quot;, &quot;value&quot;: 1}
{&quot;_id&quot; : &quot;00003&quot;, &quot;value&quot;: 1}
{&quot;_id&quot; : &quot;00004&quot;, &quot;value&quot;: 4}
</pre></div>


<p>And it has an index <code>{name: value, key: {value: 1}}</code> in it. We can just do:</p>
<div class="highlight"><pre><span></span><span class="nt">db</span><span class="p">.</span><span class="nc">getCollection</span><span class="o">(</span><span class="s1">&#39;items&#39;</span><span class="o">)</span><span class="p">.</span><span class="nc">find</span><span class="o">(</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="err">{$</span><span class="n">lt</span><span class="o">:</span> <span class="mi">4</span><span class="p">}</span><span class="err">}</span><span class="o">);</span>
</pre></div>


<p>This would return documents with ids <code>['00001', '00002, '00003']</code>
Works like charm, super fast, doesn't really depend on number of documents, etc. But what if value doesn't exist in every document?</p>
<h1>Including documents with non-existing values</h1>
<p>If our collection looks like:</p>
<div class="highlight"><pre><span></span>{&quot;_id&quot; : &quot;00001&quot;, &quot;value&quot;: 1}
{&quot;_id&quot; : &quot;00002&quot;}
{&quot;_id&quot; : &quot;00003&quot;, &quot;value&quot;: null}
{&quot;_id&quot; : &quot;00004&quot;, &quot;value&quot;: 4}
</pre></div>


<p>This query above would return the documents where value <strong>does</strong> exist, number and is less then 7.
And there will be just one matching document: <code>'00001'</code>. Which probably isn't what we want.</p>
<p>There're 2 ways to query this:</p>
<p>1. Check for null</p>
<div class="highlight"><pre><span></span><span class="nt">db</span><span class="p">.</span><span class="nc">getCollection</span><span class="o">(</span><span class="s1">&#39;items&#39;</span><span class="o">)</span><span class="p">.</span><span class="nc">find</span><span class="o">(</span><span class="p">{</span><span class="err">$</span><span class="n">or</span><span class="p">:</span> <span class="cp">[</span><span class="p">{</span><span class="nb">field</span><span class="p">:</span> <span class="kt">null</span><span class="p">},</span> <span class="p">{</span><span class="nb">field</span><span class="p">:</span> <span class="p">{</span><span class="nv">$lt</span><span class="p">:</span> <span class="mi">7</span><span class="p">}}</span><span class="cp">]</span><span class="p">}</span><span class="o">);</span>
</pre></div>


<p>2. Check for non-existing field</p>
<div class="highlight"><pre><span></span><span class="nt">db</span><span class="p">.</span><span class="nc">getCollection</span><span class="o">(</span><span class="s1">&#39;items&#39;</span><span class="o">)</span><span class="p">.</span><span class="nc">find</span><span class="o">(</span><span class="p">{</span><span class="err">$</span><span class="n">or</span><span class="p">:</span> <span class="cp">[</span><span class="p">{</span><span class="nb">field</span><span class="p">:</span> <span class="p">{</span><span class="nv">$exists</span><span class="p">:</span> <span class="kc">false</span><span class="p">}},</span> <span class="p">{</span><span class="nb">field</span><span class="p">:</span> <span class="p">{</span><span class="nv">$lt</span><span class="p">:</span> <span class="mi">7</span><span class="p">}}</span><span class="cp">]</span><span class="p">}</span><span class="o">);</span>
</pre></div>


<p>Query #1 will return all documents we want, i.e. <code>['00001', '00002, '00003']</code>. But there's a caveat.
It appears that it does <code>COLSCAN</code> if you have lots of documents with missing <code>value</code> field.</p>
<p>Query #2 will <strong>not</strong> return <code>'00003'</code>, cause <code>value</code> does exist. But it apparently does <code>FETCH</code> which
is much much faster.</p>
<h1>Avoid using $ne, unless absolutely needed</h1>
<p>See <a href="https://docs.mongodb.com/manual/reference/operator/query/ne/#op._S_ne">mongo documentation</a>:</p>
<blockquote>
<p>The inequality operator $ne is not very selective since it often matches a large portion of the index. As a result, in many cases, a $ne query with an index may perform no better than a $ne query that must scan all documents in a collection. See also <a href="https://docs.mongodb.com/manual/core/query-optimization/#read-operations-query-selectivity">Query Selectivity</a>.</p>
</blockquote>
<p>Trying to trick mongo and doing <code>{value: {$gt: 5, $lt: 5}}</code> won't help either, cause in this case it looks like it applies two conditions to the index separately and
then intersects results. Something similar it does when it evaluates <code>$ne</code>. If you really need to do this - you'd need to narrow the query somehow.</p>
<h1>Conclusion</h1>
<ol>
<li>Try to pre-populate indexed fields, if it's possible</li>
<li>If you're going to use comparision operators - don't mix up the types, you'd be surprised.</li>
<li>If you need to include the documents with missing indexed field - use <code>{value: {$exist: false}}</code> in favour of <code>{value: null}</code>.</li>
</ol>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>